/**
 * 装饰模式 VS 适配器模式
 * 装饰模式和适配器模式在通用类图上没有太多的相似点，差别比较大
 * 但是它们的功能有相似的地方：都是包装作用，都是通过委托方式实现其功能。
 * 不同点是：
 * 装饰模式包装的是自己的兄弟类，隶属于同一个家族（相同接口或父类）。
 * 适配器模式则修饰非血缘关系类，把一个非本家族的对象伪装成本家族的对象，注意是伪装，因此它的本质还是非相同接口的对象。
 *
 * 意图不同：
 * 装饰模式的意图是加强对象的功能，
 * 例子中就是把一个怯弱的小天鹅强化成了一个美丽、自信的白天鹅，
 * 它不改变类的行为和属性，只是增加（当然了，减弱类的功能也是可能存在的）功能，使美丽更加美丽，强壮更加强壮，安全更加安全；
 * 而适配器模式关注的则是转化，它的主要意图是两个不同对象之间的转化，
 * 它可以把一个天鹅转化为一个小鸭子看待，也可以把一只小鸭子看成是一只天鹅(那估计要在小鸭子的背上装个螺旋桨了)，它关注转换。
 *
 * 施与对象不同：
 * 装饰模式装饰的对象必须是自己的同宗，也就是相同的接口或父类，只要在具有相同的属性和行为的情况下，才能比较行为是增加还是减弱；
 * 适配器模式则必须是两个不同的对象，因为它着重于转换，只有两个不同的对象才有转换的必要，如果是相同对象还转换什么？！
 *
 * 场景不同：
 * 装饰模式在任何时候都可以使用，只要是想增强类的功能，
 * 而适配器模式则是一个补救模式，一般出现在系统成熟或已经构建完毕的项目中，作为一个紧急处理手段采用。
 *
 * 扩展性不同：
 * 装饰模式很容易扩展！今天不用这个修饰，好，去掉；明天想再使用，好，加上。这都没有问题。而且装饰类可以继续扩展下去；
 * 但是适配器模式就不同了，它在两个不同对象之间架起了一座沟通的桥梁，建立容易，去掉就比较困难了，需要从系统整体考虑是否能够撤销。
 */
package com.example.chapter31.unit2;